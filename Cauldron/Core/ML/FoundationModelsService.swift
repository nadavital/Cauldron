//
//  FoundationModelsService.swift
//  Cauldron
//
//  Created by Nadav Avital on 10/2/25.
//

import Foundation
import Combine
import FoundationModels

// MARK: - Type Aliases

/// Type alias for streaming recipe generation snapshots
/// Note: The actual PartiallyGenerated type is auto-generated by the @Generable macro
typealias RecipeSnapshot = GeneratedRecipe.PartiallyGenerated

/// Service for Apple Intelligence on-device recipe generation
/// Uses Foundation Models framework for structured content generation
actor FoundationModelsService {

    init() {
        // No persistent session - we create fresh sessions per request to avoid context accumulation
    }

    /// Create a fresh session with recipe-specific instructions
    private func createSession() -> LanguageModelSession {
        LanguageModelSession(
            instructions: {
                """
                Generate practical recipes with clear measurements and detailed steps.
                Do not include timers on most steps - only on long cooking steps like baking or boiling.
                """
            }
        )
    }

    /// Check if Apple Intelligence is available on this device
    var isAvailable: Bool {
        get async {
            // Check if Foundation Models are available
            switch SystemLanguageModel.default.availability {
            case .available:
                return true
            case .unavailable:
                return false
            }
        }
    }

    /// Generate a complete recipe from a text prompt with streaming updates
    /// - Parameter prompt: Natural language description of the desired recipe
    /// - Returns: AsyncThrowingStream of partial recipe updates
    nonisolated func generateRecipe(from prompt: String) -> AsyncThrowingStream<GeneratedRecipe.PartiallyGenerated, Error> {
        AsyncThrowingStream { continuation in
            Task {
                do {
                    // Create a fresh session for each generation to avoid context window issues
                    let session = await self.createSession()

                    let stream = session.streamResponse(
                        generating: GeneratedRecipe.self,
                        includeSchemaInPrompt: false,
                        options: GenerationOptions(sampling: .greedy)
                    ) {
                        "Generate a recipe for: \(prompt)"

                        "Example format:"
                        GeneratedRecipe.examplePasta
                    }

                    for try await partialResponse in stream {
                        // partialResponse.content is GeneratedRecipe.PartiallyGenerated
                        continuation.yield(partialResponse.content)
                    }

                    continuation.finish()
                } catch {
                    continuation.finish(throwing: error)
                }
            }
        }
    }

    /// Parse text into structured recipe using on-device model
    func parseRecipeText(_ text: String) async throws -> Recipe? {
        guard await isAvailable else {
            return nil // Fallback to heuristic parsing
        }

        do {
            // Create a fresh session for parsing to avoid context accumulation
            let session = createSession()

            let result = try await session.respond(
                to: """
                Parse the following recipe text into a structured format:

                \(text)

                Extract the title, ingredients with quantities, cooking steps, yields, and any other relevant information.
                """,
                generating: GeneratedRecipe.self,
                options: GenerationOptions(temperature: 0.3)
            )

            return result.content.toRecipe()
        } catch {
            // If AI parsing fails, return nil to fall back to heuristic parsing
            return nil
        }
    }

    /// Rewrite step text for clarity
    func clarifyStep(_ stepText: String) async throws -> String? {
        guard await isAvailable else {
            return nil
        }

        // Create a fresh session for clarifying to avoid context accumulation
        let session = createSession()

        let result = try await session.respond(
            to: """
            Rewrite this cooking step to be more clear and concise, maintaining all important details:
            \(stepText)
            """
        )

        return result.content
    }
}

// MARK: - @Generable Recipe Model

/// Recipe structure for Apple Intelligence generation
/// The @Generable macro enables streaming partial updates via PartiallyGenerated
@Generable
struct GeneratedRecipe: Equatable {
    @Guide(description: "A clear, descriptive recipe title")
    let title: String
    @Guide(description: "Number of servings (e.g., '4 servings')")
    let yields: String
    @Guide(description: "Total cooking time in minutes")
    let totalMinutes: Int?
    @Guide(description: "List of ingredients with quantities")
    @Guide(.count(5...15))
    let ingredients: [GeneratedIngredient]
    @Guide(description: "Step-by-step cooking instructions")
    @Guide(.count(3...12))
    let steps: [GeneratedStep]
    @Guide(description: "Relevant tags or categories")
    @Guide(.count(1...5))
    let tags: [String]
    let notes: String?

    /// Convert to domain Recipe model
    func toRecipe() -> Recipe {
        let recipeIngredients = ingredients.map { genIng -> Ingredient in
            var quantity: Quantity? = nil
            if let value = genIng.quantityValue,
               let unitStr = genIng.quantityUnit,
               let unit = UnitKind(rawValue: unitStr) {
                quantity = Quantity(value: value, unit: unit)
            }
            return Ingredient(id: UUID(), name: genIng.name, quantity: quantity, note: genIng.note)
        }

        let recipeSteps = steps.enumerated().map { index, genStep -> CookStep in
            var timers: [TimerSpec] = []

            // First, use the timer from AI if available
            if let timerSeconds = genStep.timerSeconds, timerSeconds > 0 {
                timers.append(TimerSpec(id: UUID(), seconds: timerSeconds))
            } else {
                // Fallback: Extract timers from step text
                let extractedTimers = TimerExtractor.extractTimers(from: genStep.text)
                timers.append(contentsOf: extractedTimers)
            }

            return CookStep(id: UUID(), index: index, text: genStep.text, timers: timers)
        }

        let recipeTags = tags.map { Tag(id: UUID(), name: $0) }

        return Recipe(
            title: title,
            ingredients: recipeIngredients,
            steps: recipeSteps,
            yields: yields,
            totalMinutes: totalMinutes,
            tags: recipeTags,
            nutrition: nil, // Nutrition not generated by AI to avoid inaccuracy
            notes: notes
        )
    }
}

// MARK: - Example Recipe for AI Reference

extension GeneratedRecipe {
    /// Minimal example to guide AI generation (optimized for small context window)
    static let examplePasta = GeneratedRecipe(
        title: "Simple Garlic Pasta",
        yields: "2 servings",
        totalMinutes: 15,
        ingredients: [
            GeneratedIngredient(name: "pasta", quantityValue: 8, quantityUnit: "oz", note: nil),
            GeneratedIngredient(name: "garlic", quantityValue: 3, quantityUnit: "clove", note: "minced"),
            GeneratedIngredient(name: "olive oil", quantityValue: 2, quantityUnit: "tbsp", note: nil),
            GeneratedIngredient(name: "salt", quantityValue: 1, quantityUnit: "tsp", note: nil),
            GeneratedIngredient(name: "parmesan", quantityValue: 0.25, quantityUnit: "cup", note: "grated")
        ],
        steps: [
            GeneratedStep(text: "Bring large pot of salted water to boil", timerSeconds: nil),
            GeneratedStep(text: "Cook pasta for 10 minutes until al dente", timerSeconds: 600),
            GeneratedStep(text: "Meanwhile, heat olive oil in a pan over medium heat", timerSeconds: nil),
            GeneratedStep(text: "Add minced garlic and cook until fragrant, about 30 seconds", timerSeconds: nil),
            GeneratedStep(text: "Drain pasta and toss with garlic oil", timerSeconds: nil),
            GeneratedStep(text: "Top with parmesan and serve immediately", timerSeconds: nil)
        ],
        tags: ["pasta", "quick", "vegetarian"],
        notes: nil
    )
}

@Generable
struct GeneratedIngredient: Equatable {
    @Guide(description: "Ingredient name (e.g., 'chicken breast')")
    let name: String
    @Guide(description: "Quantity amount - always provide for measurable ingredients")
    let quantityValue: Double?
    @Guide(description: "Unit like 'cup', 'tbsp', 'tsp', 'oz', 'lb', 'piece' - required when quantityValue is set")
    let quantityUnit: String?
    @Guide(description: "Optional preparation note (e.g., 'diced', 'at room temperature')")
    let note: String?
}

@Generable
struct GeneratedStep: Equatable {
    @Guide(description: "Clear instruction text for this step")
    let text: String
    @Guide(description: "Timer in seconds ONLY for longer cooking times (5+ minutes) like baking, boiling, or simmering. If step says 'bake for 25 minutes', set to 1500. Leave null for most steps - do NOT set to 0. Only use for specific timed cooking, not prep work.")
    let timerSeconds: Int?
}

// MARK: - Errors

enum FoundationModelsError: LocalizedError {
    case notAvailable
    case generationFailed
    case invalidResponse

    var errorDescription: String? {
        switch self {
        case .notAvailable:
            return "Apple Intelligence is not available on this device"
        case .generationFailed:
            return "Failed to generate recipe"
        case .invalidResponse:
            return "Received invalid response from AI"
        }
    }
}
